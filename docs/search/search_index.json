{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RobotDART RobotDART is a C++11 robot simulator (with optional Python bindings) built on top of the DART physics engine. The RobotDART simulator is intended to be used by Robotics and Machine Learning researchers who want to write controllers or test learning algorithms without the delays and overhead that usually comes with other simulators (e.g., Gazebo , Coppelia-sim ). For this reason, the simulator runs headless by default , and there is the possibility of rendering the scene (e.g., through a camera sensor) without opening a graphics window . All RobotDART's code is thread-safe (including graphics and camera sensors ), and thus enables its users to use their code in parallel jobs in multicore computers . In a few words, RobotDART combines: a physics engine (DART) an optional graphics engine (Magnum) a few sensor classes (IMU, force/torque sensors, cameras, etc.) a curated URDF library ... and a few useful features to make the life of roboticists/researchers easier Main Features Modern C++ code that makes it easy to develop environments and applications Fast and reliable simulation of robotic mechanisms and their interactions (through the DART physics engine) A structured Robot class that enables a unified creation and access to all important values: in RobotDART you can load any robot description file (URDF, SDF, SKEL, and MuJoCo files) with the same command, and all robot measurements can be queried without using any DART code A generic RobotControl class that enables fast prototyping of any type of controller A generic Sensor class that allows the creation of any kind of sensor A growing list of already implemented sensors , that includes 6-axis ForceTorque , IMU , RGB , and RGB-D sensors A simulation class ( RobotDARTSimu ) that handles multiple robots and sensors, and allows for step-by-step simulation A growing list of supported robots along with edited and optimized models to be used with RobotDART (see the robots page for details and examples): PAL Talos humanoid Franka Emika Panda KUKA LBR Iiwa (14kg version) IIT iCub humanoid (without hands) Dynamixel-based 6-legged robot A simple arm for educational purposes and you can use any URDF A custom graphical interface built on top of Magnum that allows generic customization Support for windowless OpenGL context creation (even in parallel threads!) to allow for camera sensor usage even in parallel jobs running on clusters Support for video recording in simulation time (i.e., not affected by delays of simulator and/or graphics) for visualization or debugging purposes Full-featured Python bindings for fast prototyping RobotDART runs on any Linux distribution and Mac OS What RobotDART is not RobotDART is primarily intended to be non-interactive (run a simulation, record/view the result), Interaction is limited to changing the view and your own code. No GUI for adding objects or interactively build an environment, RobotDART is not optimized for wheeled robots, RobotDART is not optimized for simulating complex (e.g., mountain-like) terrains.","title":"Home"},{"location":"#robotdart","text":"RobotDART is a C++11 robot simulator (with optional Python bindings) built on top of the DART physics engine. The RobotDART simulator is intended to be used by Robotics and Machine Learning researchers who want to write controllers or test learning algorithms without the delays and overhead that usually comes with other simulators (e.g., Gazebo , Coppelia-sim ). For this reason, the simulator runs headless by default , and there is the possibility of rendering the scene (e.g., through a camera sensor) without opening a graphics window . All RobotDART's code is thread-safe (including graphics and camera sensors ), and thus enables its users to use their code in parallel jobs in multicore computers . In a few words, RobotDART combines: a physics engine (DART) an optional graphics engine (Magnum) a few sensor classes (IMU, force/torque sensors, cameras, etc.) a curated URDF library ... and a few useful features to make the life of roboticists/researchers easier","title":"RobotDART"},{"location":"#main-features","text":"Modern C++ code that makes it easy to develop environments and applications Fast and reliable simulation of robotic mechanisms and their interactions (through the DART physics engine) A structured Robot class that enables a unified creation and access to all important values: in RobotDART you can load any robot description file (URDF, SDF, SKEL, and MuJoCo files) with the same command, and all robot measurements can be queried without using any DART code A generic RobotControl class that enables fast prototyping of any type of controller A generic Sensor class that allows the creation of any kind of sensor A growing list of already implemented sensors , that includes 6-axis ForceTorque , IMU , RGB , and RGB-D sensors A simulation class ( RobotDARTSimu ) that handles multiple robots and sensors, and allows for step-by-step simulation A growing list of supported robots along with edited and optimized models to be used with RobotDART (see the robots page for details and examples): PAL Talos humanoid Franka Emika Panda KUKA LBR Iiwa (14kg version) IIT iCub humanoid (without hands) Dynamixel-based 6-legged robot A simple arm for educational purposes and you can use any URDF A custom graphical interface built on top of Magnum that allows generic customization Support for windowless OpenGL context creation (even in parallel threads!) to allow for camera sensor usage even in parallel jobs running on clusters Support for video recording in simulation time (i.e., not affected by delays of simulator and/or graphics) for visualization or debugging purposes Full-featured Python bindings for fast prototyping RobotDART runs on any Linux distribution and Mac OS","title":"Main Features"},{"location":"#what-robotdart-is-not","text":"RobotDART is primarily intended to be non-interactive (run a simulation, record/view the result), Interaction is limited to changing the view and your own code. No GUI for adding objects or interactively build an environment, RobotDART is not optimized for wheeled robots, RobotDART is not optimized for simulating complex (e.g., mountain-like) terrains.","title":"What RobotDART is not"},{"location":"faq/","text":"Frequently Asked Questions This pages provides a user guide of the library through Frequently Asked Questions (FAQ). What is a minimal, working example of RobotDART What robots are supported in RobotDART? RobotDART supports any robot that can be described by a URDF, SDF, SKEL or MJCF file. Nevertheless, we have a curated list of robots with edited and optimized models to be used with RobotDART (see the robots page for details and examples). How can I load my own URDF/SDF/SKEL/MJCF file? See the robots page for details. How do I enable graphics in my code? How do I record a video? How can I manipulate the camera? How can I display debug information? What do the numbers in the status bar mean? How can I visualize the state of my model? Can I add change the graphics scene (e.g., change lighting conditions)? How can I control my robot? Can I have a position-,velocity-,torque-controlled robot? Is there a way to control the simulation timestep? What is the difference between the DART and the FCL collision detector? How can I choose between them? My robot does not self-collide. How can I change this? How can I compute kinematic/dynamic properties of my robot (e.g., Jacobians, Mass Matrix)? Is there a way to change the joint or link (body) properties (e.g., actuation, mass)? What are the supported sensors? How can I use an IMU? I want to have multiple camera sensors. Is it possible? How can I attach a camera to a moving link? How can I measure forces being applied to my robot? How can I spawn multiple robots in parallel? I need to simulate many worlds with camera sensors in parallel. How can I do this? I do not know how to use waf. How can I detect RobotDART from CMake? I prefer coding in python. How can I use RobotDART?","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"This pages provides a user guide of the library through Frequently Asked Questions (FAQ).","title":"Frequently Asked Questions"},{"location":"faq/#what-is-a-minimal-working-example-of-robotdart","text":"","title":"What is a minimal, working example of RobotDART"},{"location":"faq/#what-robots-are-supported-in-robotdart","text":"RobotDART supports any robot that can be described by a URDF, SDF, SKEL or MJCF file. Nevertheless, we have a curated list of robots with edited and optimized models to be used with RobotDART (see the robots page for details and examples).","title":"What robots are supported in RobotDART?"},{"location":"faq/#how-can-i-load-my-own-urdfsdfskelmjcf-file","text":"See the robots page for details.","title":"How can I load my own URDF/SDF/SKEL/MJCF file?"},{"location":"faq/#how-do-i-enable-graphics-in-my-code","text":"","title":"How do I enable graphics in my code?"},{"location":"faq/#how-do-i-record-a-video","text":"","title":"How do I record a video?"},{"location":"faq/#how-can-i-manipulate-the-camera","text":"","title":"How can I manipulate the camera?"},{"location":"faq/#how-can-i-display-debug-information","text":"","title":"How can I display debug information?"},{"location":"faq/#what-do-the-numbers-in-the-status-bar-mean","text":"","title":"What do the numbers in the status bar mean?"},{"location":"faq/#how-can-i-visualize-the-state-of-my-model","text":"","title":"How can I visualize the state of my model?"},{"location":"faq/#can-i-add-change-the-graphics-scene-eg-change-lighting-conditions","text":"","title":"Can I add change the graphics scene (e.g., change lighting conditions)?"},{"location":"faq/#how-can-i-control-my-robot-can-i-have-a-position-velocity-torque-controlled-robot","text":"","title":"How can I control my robot? Can I have a position-,velocity-,torque-controlled robot?"},{"location":"faq/#is-there-a-way-to-control-the-simulation-timestep","text":"","title":"Is there a way to control the simulation timestep?"},{"location":"faq/#what-is-the-difference-between-the-dart-and-the-fcl-collision-detector-how-can-i-choose-between-them","text":"","title":"What is the difference between the DART and the FCL collision detector? How can I choose between them?"},{"location":"faq/#my-robot-does-not-self-collide-how-can-i-change-this","text":"","title":"My robot does not self-collide. How can I change this?"},{"location":"faq/#how-can-i-compute-kinematicdynamic-properties-of-my-robot-eg-jacobians-mass-matrix","text":"","title":"How can I compute kinematic/dynamic properties of my robot (e.g., Jacobians, Mass Matrix)?"},{"location":"faq/#is-there-a-way-to-change-the-joint-or-link-body-properties-eg-actuation-mass","text":"","title":"Is there a way to change the joint or link (body) properties (e.g., actuation, mass)?"},{"location":"faq/#what-are-the-supported-sensors-how-can-i-use-an-imu","text":"","title":"What are the supported sensors? How can I use an IMU?"},{"location":"faq/#i-want-to-have-multiple-camera-sensors-is-it-possible-how-can-i-attach-a-camera-to-a-moving-link","text":"","title":"I want to have multiple camera sensors. Is it possible? How can I attach a camera to a moving link?"},{"location":"faq/#how-can-i-measure-forces-being-applied-to-my-robot","text":"","title":"How can I measure forces being applied to my robot?"},{"location":"faq/#how-can-i-spawn-multiple-robots-in-parallel","text":"","title":"How can I spawn multiple robots in parallel?"},{"location":"faq/#i-need-to-simulate-many-worlds-with-camera-sensors-in-parallel-how-can-i-do-this","text":"","title":"I need to simulate many worlds with camera sensors in parallel. How can I do this?"},{"location":"faq/#i-do-not-know-how-to-use-waf-how-can-i-detect-robotdart-from-cmake","text":"","title":"I do not know how to use waf. How can I detect RobotDART from CMake?"},{"location":"faq/#i-prefer-coding-in-python-how-can-i-use-robotdart","text":"","title":"I prefer coding in python. How can I use RobotDART?"},{"location":"robots/","text":"Supported robots Every robot is a defined as a URDF, which will be installed $PREFIX/shared/robot_dart/robots . Some robots (Talos, iCub) have pre-defined \"robot classes\" that define sensors and other properties; for the other robot, you will have to add the sensors/properties via the generic robot class. The URDF files are loaded using the following rules (see Robot::_get_path() ): First check in the current directory If not found, check in current_directory/robots If not found, check in $ROBOT_DART_PATH/robots If not found, check in the robot dart installation path/robots (e.g., /usr/share/robot_dart/robots or $HOME/share/robot_dart/robots ) Otherwise, report failure Talos (PAL Robotics) Talos is a humanoid robot made by PAL Robotics . Datasheet: [ pdf ] 32 degrees of freedom (6 for each leg, 7 for each arm, 2 for the waist, 2 for the neck, 1 for each gripper) 175 cm / 95 kg IMU in the torso Torque sensors in all joints except head, wrist and gripper (22 torque sensors total) 1 force/torque sensor in each ankle 1 force/torque sensor in each wrist We have two URDF files: robots/talos/talos.urdf : accurate (simplified but made of polygons) collision meshes mimic joints for the gripper Not compatible the DART collision detector (you need to use FCL collision detector - shipped with DART) URDF: [ talos.urdf ] Example: [ talos.cpp ] robot/talos/talos_fast.urdf : no collision except for the feet, which are approximated by boxes grippers are fixed (no movement is allowed) compatible with the DART collision detector URDF: [ talos.urdf ] Example: [ talos.cpp ] talos_fast.urdf is faster because it makes it possible to use the DART collision detector (and has much collision shapes). You should prefer it except if you want to use the grippers (e.g., for manipulation) or are working on self-collisions. Please note that the mesh files (.glb) require assimp 5.x (and not assimp4.x usually shipped with ROS). If you cannot load the URDF, please check your assimp version. Panda (Franka Emika) The Franka is a modern manipulator made by Franka Emika Panda . It is commonly found in many robotics labs. Datasheet: [ pdf ] 7 degrees of freedom Can be controlled in torque 18 kg workspace: 855 mm (horizontal), 1190 mm (vertical) URDF: [ franka.urdf ] Example: [ franka.cpp ] The URDF includes the gripper. LBR iiwa (KUKA) The LBR iiwa is manufactured by KUKA . It is similar to the Panda and is also very common in robotics labs. Datasheet: [ pdf ] We implement the 14 kg version 29.5 kg 7 degrees of freedom URDF: [ iiwa.urdf ] Example: [ iiwa.cpp ] iCub (IIT) The iCub is a open source humanoid robot made by the Instituto Italiano di Tecnologia . There are currently 42 iCUbs in the world, and many versions. Datasheet (rev 2.3) [ pdf ] 6 force/torque sensors (upper arms, upper legs, ankles) IMU in the head We do to simulate the skin We do not simulate the hands Our model is close to the Inria's iCub , but it has not been checked in detail. URDF: [ icub.urdf ] Example [ icub.cpp ] Please note that the mesh files (.glb) require assimp 5.x (and not assimp4.x usually shipped with ROS). If you cannot load the URDF, please check your assimp version. Dynamixel-based hexapod robot (Inria and others) This hexapod is a simple 6-legged robot based on dynamixel actuators. It is similar to the robot used in the paper `Robots that can adapt like animals' (Cully et al., 2015). 6 legs, 3 degrees of freedom for each leg (18 degrees of freedom) simple URDF (no meshes) URDF: [ pexod.urdf ] Example: [ hexapod.cpp ] Simple arm A simple arm for educational or debugging purposes 5 degrees of freedom simple URDF (no meshes) URDF: [ pexod.urdf ] Example: [ arm.cpp ] How to use your own URDF? TO-DO","title":"Supported robots"},{"location":"robots/#supported-robots","text":"Every robot is a defined as a URDF, which will be installed $PREFIX/shared/robot_dart/robots . Some robots (Talos, iCub) have pre-defined \"robot classes\" that define sensors and other properties; for the other robot, you will have to add the sensors/properties via the generic robot class. The URDF files are loaded using the following rules (see Robot::_get_path() ): First check in the current directory If not found, check in current_directory/robots If not found, check in $ROBOT_DART_PATH/robots If not found, check in the robot dart installation path/robots (e.g., /usr/share/robot_dart/robots or $HOME/share/robot_dart/robots ) Otherwise, report failure","title":"Supported robots"},{"location":"robots/#talos-pal-robotics","text":"Talos is a humanoid robot made by PAL Robotics . Datasheet: [ pdf ] 32 degrees of freedom (6 for each leg, 7 for each arm, 2 for the waist, 2 for the neck, 1 for each gripper) 175 cm / 95 kg IMU in the torso Torque sensors in all joints except head, wrist and gripper (22 torque sensors total) 1 force/torque sensor in each ankle 1 force/torque sensor in each wrist We have two URDF files: robots/talos/talos.urdf : accurate (simplified but made of polygons) collision meshes mimic joints for the gripper Not compatible the DART collision detector (you need to use FCL collision detector - shipped with DART) URDF: [ talos.urdf ] Example: [ talos.cpp ] robot/talos/talos_fast.urdf : no collision except for the feet, which are approximated by boxes grippers are fixed (no movement is allowed) compatible with the DART collision detector URDF: [ talos.urdf ] Example: [ talos.cpp ] talos_fast.urdf is faster because it makes it possible to use the DART collision detector (and has much collision shapes). You should prefer it except if you want to use the grippers (e.g., for manipulation) or are working on self-collisions. Please note that the mesh files (.glb) require assimp 5.x (and not assimp4.x usually shipped with ROS). If you cannot load the URDF, please check your assimp version.","title":"Talos (PAL Robotics)"},{"location":"robots/#panda-franka-emika","text":"The Franka is a modern manipulator made by Franka Emika Panda . It is commonly found in many robotics labs. Datasheet: [ pdf ] 7 degrees of freedom Can be controlled in torque 18 kg workspace: 855 mm (horizontal), 1190 mm (vertical) URDF: [ franka.urdf ] Example: [ franka.cpp ] The URDF includes the gripper.","title":"Panda (Franka Emika)"},{"location":"robots/#lbr-iiwa-kuka","text":"The LBR iiwa is manufactured by KUKA . It is similar to the Panda and is also very common in robotics labs. Datasheet: [ pdf ] We implement the 14 kg version 29.5 kg 7 degrees of freedom URDF: [ iiwa.urdf ] Example: [ iiwa.cpp ]","title":"LBR iiwa (KUKA)"},{"location":"robots/#icub-iit","text":"The iCub is a open source humanoid robot made by the Instituto Italiano di Tecnologia . There are currently 42 iCUbs in the world, and many versions. Datasheet (rev 2.3) [ pdf ] 6 force/torque sensors (upper arms, upper legs, ankles) IMU in the head We do to simulate the skin We do not simulate the hands Our model is close to the Inria's iCub , but it has not been checked in detail. URDF: [ icub.urdf ] Example [ icub.cpp ] Please note that the mesh files (.glb) require assimp 5.x (and not assimp4.x usually shipped with ROS). If you cannot load the URDF, please check your assimp version.","title":"iCub (IIT)"},{"location":"robots/#dynamixel-based-hexapod-robot-inria-and-others","text":"This hexapod is a simple 6-legged robot based on dynamixel actuators. It is similar to the robot used in the paper `Robots that can adapt like animals' (Cully et al., 2015). 6 legs, 3 degrees of freedom for each leg (18 degrees of freedom) simple URDF (no meshes) URDF: [ pexod.urdf ] Example: [ hexapod.cpp ]","title":"Dynamixel-based hexapod robot (Inria and others)"},{"location":"robots/#simple-arm","text":"A simple arm for educational or debugging purposes 5 degrees of freedom simple URDF (no meshes) URDF: [ pexod.urdf ] Example: [ arm.cpp ]","title":"Simple arm"},{"location":"robots/#how-to-use-your-own-urdf","text":"TO-DO","title":"How to use your own URDF?"}]}